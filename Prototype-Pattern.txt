Патерн Прототип (Prototype Pattern)

Сенс патерну.
    Прототип – це породжуючий патерн проектування, який дозволяє копіювати об'єкти, не вдаючись до подробиць їх реалізації; копіювати об'єкти будь-якої складності без прив'язки до конкретних класів.

Проблема.
    Ви маєте об'єкт, який потрібно скопіювати. Як це зробити? Потрібно створити порожній об'єкт такого ж класу, а потім по черзі скопіювати значення всіх полів зі старого об'єкта на новий.
    В даному вирішенні є 2 проблеми:
    1) Не кожен об'єкт вдасться скопіювати таким чином, адже частина його стану може бути приватною, а отже, недоступною для решти коду програми.
    2) Копіюючий код стане залежним від класів об'єктів, що копіюються. Адже щоб перебрати всі поля об'єкта, потрібно прив'язатися до його класу. Через це ви не зможете копіювати об'єкти, знаючи лише їхні інтерфейси, а не конкретні класи.

Рішення.
    Патерн Прототип доручає створення копій самим об'єктам, що копіюються. Він вводить спільний інтерфейс для всіх об'єктів, які підтримують клонування. Це дозволяє копіювати об'єкти, не прив'язуючись до їх класів. Зазвичай такий інтерфейс має лише один метод clone.

Реалізація методу clone:
    Метод створює новий об'єкт поточного класу і копіює значення всіх полів власного об'єкта. Так вдасться скопіювати навіть приватні поля, оскільки більшість мов програмування дозволяє доступ до приватних полів будь-якого об'єкта поточного класу.
    Об'єкт, який копіюють, називається прототипом (звідки назва патерну).

Застосування.
    1) Коли ваш код не повинен залежати від класів об'єктів, що копіюються.
    Якщо ваш код працює з об'єктами, поданими ззовні через спільний інтерфейс, то ви не можете прив'язатися до їхніх класів, оскільки їх конкретні класи невідомі.
    Патерн Прототип надає клієнту загальний інтерфейс для роботи з усіма макетами. Клієнту не потрібно залежати від усіх класів об'єктів, що копіюються, а тільки від інтерфейсу клонування.
    2) Коли ви маєте безліч підкласів, які відрізняються початковими значеннями полів. Хтось міг створити всі ці класи, щоб легко породжувати об'єкти з певною конфігурацією.
    Патерн Прототип пропонує використовувати набір прототипів замість створення підкласів для опису популярних конфігурацій об'єктів.
    Таким чином, замість породження об'єктів з підкласів, ви копіюватимете існуючі об'єкти-прототипи, в яких вже налаштовано внутрішній стан. Це дозволить уникнути вибухового зростання кількості класів у програмі та зменшити її складність.

Кроки реалізації.
     1) Створіть інтерфейс прототипів із єдиним методом clone. Якщо у вас є ієрархія продуктів, метод клонування можна оголосити у кожному з її класів.
     2) Додайте до класів майбутніх прототипів альтернативний конструктор, який приймає як аргумент об'єкт поточного класу. Цей конструктор повинен скопіювати з поданого об'єкта значення всіх полів, оголошених у межах поточного класу, та потім передати виконання батьківському конструктору, щоб той подбав про поля, оголошені суперкласі.
     Якщо ваша мова програмування не підтримує перевантаження методів, вам не вдасться створити кілька версій конструктора. В даному випадку копіювання значень можна проводити й у іншому методі, спеціально створеному для цих цілей. Конструктор зручніший тим, що дозволяє клонувати об'єкт за один виклик.
     3) Метод клонування зазвичай складається з одного рядка: виклику оператора new з конструктором прототипу. Усі класи, що підтримують клонування, повинні явно визначити метод clone, щоб використовувати власний клас із оператором new. У іншому випадку результатом клонування стане об'єкт батьківського класу.
     4) Опціонально створіть центральне сховище прототипів. У ньому зручно зберігати варіації об'єктів, можливо, навіть одного класу, але по-різному налаштованих.
     Ви можете розмістити це сховище або у новому фабричному класі, або у фабричному методі базового класу прототипів. Такий фабричний метод повинен на підставі вхідних аргументів шукати в сховищі прототипів відповідний екземпляр, а потім викликати його метод клонування та повертати отриманий об'єкт.
     Нарешті, потрібно позбавитися прямих викликів конструкторів об'єктів, замінивши їх викликами фабричного методу сховища прототипів.

 Переваги та недоліки.
     Переваги:
     1) Дозволяє клонувати об'єкти, не прив'язуючись до їх класів.
     2) Менше повторюваного коду ініціалізації об'єктів.
     3) Прискорює створення об'єктів.
     4) Альтернатива створенню підкласів для конструювання складних об'єктів.
     Недоліки:
     1) Складно клонувати складові об'єкти, які мають посилання на інші об'єкти.

 Концептуальний приклад.
     Цей приклад показує структуру патерна Прототип, а саме — з яких класів він складається, які ролі ці класи виконують і як вони взаємодіють один з одним.
     У рубі кожного об'єкта за умовчанням визначено метод clone:
     Метод clone - створює поверхневу копію obj – копіюються змінні екземпляра obj, але не об'єкти, на які вони посилаються.
     Клонування об'єкта, який має вкладений об'єкт із зворотним посиланням, потребує спеціального підходу. Після завершення клонування вкладений об'єкт повинен вказувати на клонований об'єкт, а не вихідний об'єкт.

     Примітка: https://refactoring.guru/ru/design-patterns/prototype.
